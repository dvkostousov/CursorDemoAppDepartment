# Отчет об опыте использования Cursor.ai

## Цель

Оценить возможности **Cursor.ai** в генерации и тестировании Java-приложения на основе различных входных данных. Проверить качество автогенерации, корректность логики, удобство взаимодействия и ограничения при работе с большим количеством файлов и повторяющимися итерациями.

## Задача

1. Имеется существующая Java Entity.
2. На её основе нужно:
   - Сгенерировать JSON-схему;
   - Получить SQL-скрипт создания таблицы в PostgreSQL (через pgAdmin);
   - Использовать Cursor.ai для генерации сущности на основе:
     - JSON-схемы;
     - SQL-скрипта.

## Промпт, использованный для генерации entity

> Внимательно посмотри на sql-скрипт с созданием таблицы в `department.sql` (json-схему в `Department.json`) и создай сущность `Department` с конструктором без аргументов с Hibernate-маппингом для работы с базой данных. Используй аннотации из Lombok.

## Результат

- Сгенерированные сущности по JSON-схеме и SQL-скрипту **абсолютно совпали** с оригинальной исходной сущностью.
- Вывод: **Генерация entity из JSON-схемы — особенно удобна** и позволяет точно контролировать мелкие детали структуры.

---

## Продолжение: Генерация серверной части приложения

На основе `Department` была поставлена задача сгенерировать:

- Сервисный слой
- Репозиторий (с использованием JPA и H2)
- DTO и мапперы
- REST API (контроллер)
- Тесты всех уровней

### Впечатления

- Все промпты подавались в **свободной форме**.
- Cursor.ai прекрасно понимал запросы и выдавал адекватный код.
- Работа шла быстро, удобно, результат требовал минимум правок.

---

## Генерация и улучшение тестов

### Этапы:

1. Генерация юнит-тестов → **оценка покрытия**  
   - Результаты неплохие, но был потенциал улучшения.

2. Генерация интеграционных тестов контроллера  
   - Дополнительно просил улучшить имеющиеся тесты.

3. Проведение **мутационного тестирования**  
   - Результаты: приемлемые, но с возможностью усиления.

4. Многократное повторение шагов 3–4  
   - Количество тестов резко возросло.
   - Качество сервисного слоя улучшилось.
   - **Метрики покрытия почти не росли.**

5. Проверка покрытия и анализ ошибок  
   - Обнаружено много недочетов, устранено пошагово с помощью Cursor.

6. Финальная доработка тестов  
   - Очистка дубликатов, категоризация, улучшение структуры тестов.

---

## Финальные метрики покрытия

### Покрытие кода (JaCoCo):

- Общая покрытие инструкций: **92%**
- Покрытие ветвлений: **85%**

#### По пакетам:

- `service.impl`: 94%
- `mapper`: 100%
- `entity`: 100%
- `dto`: 100%
- `controller.impl`: 88%
- Корневой пакет: 37% 

### Мутационное тестирование (PIT):

- Покрытие строк: **98%** (39 из 40)
- Мутационное покрытие: **78%** (101 из 130 мутантов убито)
- Сила тестов: **89%** (101 из 114 релевантных мутантов убито)

#### Вывод:

- **Высокое покрытие** по всем основным пакетам.
- **Хорошее мутационное покрытие**, но возможны улучшения:
  - недостаточное покрытие исключений;
  - не все граничные случаи обрабатываются.

---

## Особенности использования Cursor.ai

### Плюсы:

- Отлично понимает **естественный язык**, почти не требует строгой формулировки.
- Быстрая генерация качественного кода и тестов.
- Удобная работа с DTO, мапперами, REST-слоем.
- Может адаптироваться к улучшению кода по шагам.

### Минусы и ограничения:

- При **росте числа файлов** и итераций начинает **теряться в контексте**:
  - забывает структуру;
  - начинает предлагать изменения не в тестах, а в коде проекта;
  - требует ручного вмешательства и корректировок.

- **Командная строка (cmd)** иногда зависает:
  - особенно при выполнении длительных команд (наблюдалось на ноутбуке; на ПК было еще больше багов).

- Требуется **анимационный контроль со стороны пользователя**:
  - даже при хорошем понимании запросов результат не всегда корректный;
  - нужно проверять и тщательно следить за действиями ИИ-агента, может сбиться и начать предпринимать действия не в нужную сторону.

---

## Общий вывод

**Cursor.ai** — мощный инструмент, особенно полезный для генерации шаблонного кода, слоёв приложения и тестов. Хорошо справляется с итеративной доработкой, особенно при контроле со стороны пользователя. Однако в крупных проектах и при множественных итерациях важно **не терять контроль над качеством и логикой кода**, а также понимать границы контекста, в которых работает агент.

---

